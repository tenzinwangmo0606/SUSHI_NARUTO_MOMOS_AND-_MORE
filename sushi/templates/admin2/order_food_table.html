{% extends "admin2/base2.html" %}
{% load static %}
{% block title %}Order Details{% endblock %}
{% block content %}
<div class="container mx-auto px-4 py-8">
    <h2 class="text-2xl font-bold mb-4">Order Details</h2>

    <!-- Pending orders persistent banner (hidden when 0) -->
    <div id="pending-alert-banner"
        class="hidden mb-4 p-3 rounded text-sm bg-yellow-100 border border-yellow-300 text-yellow-900 flex items-center justify-between">
        <div id="pending-alert-text"><!-- content injected by JS --></div>
        <div class="ml-4">
            <button id="pending-ok-btn" class="bg-yellow-600 text-white px-3 py-1 rounded text-sm">OK</button>
        </div>
    </div>

    <table class="min-w-full bg-white border">
        <thead>
            <tr>
                <th class="px-4 py-2 border">s.no</th>
                <th class="px-4 py-2 border">Item</th>
                <th class="px-4 py-2 border">Mobile Number</th>
                <th class="px-4 py-2 border">Qty</th>
                <th class="px-4 py-2 border">Price</th>
                <th class="px-4 py-2 border">Total Price</th>
                <th class="px-4 py-2 border">Date</th>
                <th class="px-4 py-2 border">Time</th>
                <th class="px-4 py-2 border">Status</th>
                <th class="px-4 py-2 border">Actions</th>
            </tr>
        </thead>
        {% regroup orders by email as order_groups %}
        <tbody id="order-food-tbody">
            {% for group in order_groups %}
            <!-- Group header: shows email, item count and "One-time Order" label -->
            <tr class="bg-gray-100">
                <td class="px-4 py-2 border font-semibold" colspan="9">
                    <div class="flex items-center justify-between">
                        <div>
                            <span class="mr-2">Email:</span>
                            <strong>{{ group.grouper }}</strong>
                            <span class="mx-2 text-sm text-gray-600">
                                ({{ group.list|length }} item{% if group.list|length > 1 %}s{% endif %})
                            </span>
                        </div>
                        <div class="text-sm text-gray-600">One-time Order</div>
                    </div>
                </td>
            </tr>
            <!-- Orders for this email -->
            {% for order in group.list %}
                {% ifchanged order.created_at|time:"H:i:s" %}
                    <tr>
                        <td class="px-4 py-2 border">{{ forloop.counter }}</td>

                        <!-- Items cell: list all items that share this email+time -->
                        <td class="px-4 py-2 border">
                            {% for o in group.list %}
                                {% if o.created_at|time:"H:i:s" == order.created_at|time:"H:i:s" %}
                                    <div>{{ o.item }} <small class="text-xs text-gray-600">(x{{ o.qty }})</small></div>
                                {% endif %}
                            {% endfor %}
                        </td>

                        <!-- Mobile (use the first one for this time-group) -->
                        <td class="px-4 py-2 border">{{ order.mobile }}</td>

                        <!-- Qty column: list qtys for each item in this time-group -->
                        <td class="px-4 py-2 border">
                            {% for o in group.list %}
                                {% if o.created_at|time:"H:i:s" == order.created_at|time:"H:i:s" %}
                                    <div>{{ o.qty }}</div>
                                {% endif %}
                            {% endfor %}
                        </td>

                        <!-- Price column: list individual prices for the grouped orders -->
                        <td class="px-4 py-2 border">
                            {% for o in group.list %}
                                {% if o.created_at|time:"H:i:s" == order.created_at|time:"H:i:s" %}
                                    <div>{{ o.price|floatformat:2 }} CHF</div>
                                {% endif %}
                            {% endfor %}
                        </td>

                        <!-- Total Price column: list totals for each order in this group/time -->
                        <td class="px-4 py-2 border">
                            {% for o in group.list %}
                                {% if o.created_at|time:"H:i:s" == order.created_at|time:"H:i:s" %}
                                    <div>{{ o.total_price|floatformat:2 }} CHF</div>
                                {% endif %}
                            {% endfor %}
                        </td>

                        <td class="px-4 py-2 border">{{ order.created_at|date:"Y-m-d" }}</td>
                        <td class="px-4 py-2 border">{{ order.created_at|time:"H:i:s" }}</td>

                        <!-- Status cell: show combined visible statuses but keep hidden spans per order for JS updates -->
                        <td class="px-4 py-2 border">
                            <div class="text-sm text-gray-700">
                                {% for o in group.list %}
                                    {% if o.created_at|time:"H:i:s" == order.created_at|time:"H:i:s" %}
                                        <div class="flex items-center mb-1">
                                            <input type="checkbox" class="order-checkbox mr-2" data-order-id="{{ o.id }}" value="{{ o.id }}">
                                            <span class="inline-block">{{ o.status }}</span>
                                        </div>
                                    {% endif %}
                                {% endfor %}
                            </div>
                            <!-- hidden individual status spans so client JS can update by id -->
                            {% for o in group.list %}
                                {% if o.created_at|time:"H:i:s" == order.created_at|time:"H:i:s" %}
                                    <span id="status-{{ o.id }}" class="status-cell hidden" data-status="{{ o.status }}"></span>
                                {% endif %}
                            {% endfor %}
                        </td>

                        <!-- Actions: include one form per underlying order (keeps existing JS behavior) -->
                        <td class="px-4 py-2 border">
                            <!-- Single visible action form for this time-group.
                                 It now includes one hidden input per underlying order (name="order_ids")
                                 so the chosen action can be applied to all grouped orders. -->
                            <form method="post" action="{% url 'order_action_admin' order.id %}" class="inline order-action-form" data-order-id="{{ order.id }}">
                                {% csrf_token %}
                                <input type="hidden" name="reason" class="cancel-reason-input">
                                <div class="order-ids-container">
                                    <!-- order_ids will be added dynamically based on checked checkboxes -->
                                </div>
                                <button type="submit" name="action" value="accept" class="bg-green-500 text-white px-2 py-1 rounded text-xs">Accept</button>
                                <button type="submit" name="action" value="making" class="bg-yellow-500 text-white px-2 py-1 rounded text-xs">Making</button>
                                <button type="submit" name="action" value="collect" class="bg-blue-500 text-white px-2 py-1 rounded text-xs">Collect</button>
                                <button type="submit" name="action" value="delivered" class="bg-purple-500 text-white px-2 py-1 rounded text-xs" onclick="return confirm('Are you sure you want to deliver this order?');">Deliver</button>
                                <button type="submit" name="action" value="cancel" class="bg-red-500 text-white px-2 py-1 rounded text-xs cancel-btn">Cancel</button>
                            </form>

                            <!-- Keep hidden individual status spans so client JS can still find and update each order by id -->
                        </td>
                    </tr>
                {% endifchanged %}
            {% endfor %}
            {% endfor %}
        </tbody>
    </table>
</div>

<!-- Modal HTML -->
<div id="cancel-modal" class="fixed inset-0 bg-gray-600 bg-opacity-50 hidden items-center justify-center">
    <div class="bg-white p-6 rounded-lg shadow-xl w-1/3">
        <h3 class="text-lg font-bold mb-4">Reason for Cancellation</h3>
        <textarea id="cancel-reason-textarea" class="w-full p-2 border rounded" rows="4"
            placeholder="Please provide a reason..."></textarea>
        <div class="mt-4 flex justify-end space-x-2">
            <button id="modal-cancel-btn" class="bg-gray-500 text-white px-4 py-2 rounded">Go Back</button>
            <button id="modal-confirm-btn" class="bg-red-500 text-white px-4 py-2 rounded">Confirm Cancellation</button>
        </div>
    </div>
</div>

<!-- Audio element for pending order alert sound -->
<audio id="pending-beep-audio" preload="auto" playsinline>
    <source src="{% static 'sounds/beep1.mp3' %}" type="audio/mpeg">
</audio>

<!-- Load Firebase compat SDKs (works with firebase.initializeApp / firebase.messaging usage below).
     Using compat avoids "Unexpected token 'export'" and "Cannot use import statement outside a module" errors
     caused by loading modular (ESM) SDK files as classic scripts. -->
<script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-messaging-compat.js"></script>

<script>
    // Refresh page every 30 seconds
    setInterval(function () {
        window.location.reload();
    }, 30000); // 30 seconds

    // Initialize Firebase config (templated values)
    const firebaseConfig = {
        apiKey: "{{ FIREBASE_API_KEY }}",
        projectId: "{{ FIREBASE_PROJECT_ID }}",
        messagingSenderId: "{{ FIREBASE_SENDER_ID }}",
        appId: "{{ FIREBASE_APP_ID }}"
    };

    // Helper: check config appears valid (not empty and not unreplaced template placeholders)
    function isFirebaseConfigValid(cfg) {
        const vals = [cfg.apiKey, cfg.projectId, cfg.messagingSenderId, cfg.appId];
        return vals.every(v => typeof v === 'string' && v.trim() !== '' && !v.includes('{{'));
    }

    // Safely initialize Firebase (compat). Guard against missing SDK, double-init or incomplete config.
    let messaging = null;
    try {
        if (typeof firebase === 'undefined') {
            console.warn('Firebase SDK not loaded. Push notifications will be disabled.');
        } else if (!isFirebaseConfigValid(firebaseConfig)) {
            console.warn('Incomplete Firebase config — skipping Firebase initialization (missing projectId/apiKey/etc).');
        } else {
            // avoid re-initializing if already initialized elsewhere
            if (!firebase.apps || firebase.apps.length === 0) {
                firebase.initializeApp(firebaseConfig);
            } else {
                console.info('Firebase already initialized.');
            }

            // Only attempt to get messaging when app config is present
            try {
                messaging = firebase.messaging();
            } catch (mErr) {
                console.warn('firebase.messaging() failed:', mErr);
            }
        }
    } catch (err) {
        console.error('Firebase initialization error:', err);
    }

    // Configure Toastr
    toastr.options = {
        closeButton: true,
        progressBar: true,
        positionClass: "toast-top-right",
    };

    // helper to read csrftoken cookie
    function getCookie(name) {
        let cookieValue = null;
        if (document.cookie && document.cookie !== '') {
            const cookies = document.cookie.split(';');
            for (let i = 0; i < cookies.length; i++) {
                const cookie = cookies[i].trim();
                if (cookie.substring(0, name.length + 1) === (name + '=')) {
                    cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                    break;
                }
            }
        }
        return cookieValue;
    }
    const CSRFTOKEN = getCookie('csrftoken');

    // Helper: populate order_ids hidden inputs based on checked checkboxes
    function updateOrderIdsInForm(form) {
        const container = form.querySelector('.order-ids-container');
        if (!container) return;
        container.innerHTML = '';
        
        // Collect all checked order IDs in the same row
        const checkboxes = form.closest('tr').querySelectorAll('.order-checkbox:checked');
        checkboxes.forEach(checkbox => {
            const input = document.createElement('input');
            input.type = 'hidden';
            input.name = 'order_ids';
            input.value = checkbox.value;
            container.appendChild(input);
        });
    }

    // Print mini-card for a given table row (opens a print preview window)
    function printMiniCardForRow(row) {
        if (!row) return;

        // cells: 0:s.no,1:Item,2:Mobile,3:Qty,4:Price,5:Total,6:Date,7:Time,...
        const cells = row.querySelectorAll('td');
        if (cells.length < 8) return;

        const itemsCell = cells[1];
        const mobile = cells[2].textContent.trim();
        const qtyCell = cells[3];
        const priceCell = cells[4];
        const totalCell = cells[5];
        const date = cells[6].textContent.trim();
        const time = cells[7].textContent.trim();

        // Collect line elements (assumes same order as checkboxes rendered)
        const itemLines = Array.from(itemsCell.querySelectorAll('div')).map(d => d.innerHTML.trim());
        const qtyLines = Array.from(qtyCell.querySelectorAll('div')).map(d => d.textContent.trim());
        const priceLines = Array.from(priceCell.querySelectorAll('div')).map(d => d.textContent.trim());
        const totalLines = Array.from(totalCell.querySelectorAll('div')).map(d => d.textContent.trim());

        // Find checkboxes and determine which to print
        const allCheckboxes = Array.from(row.querySelectorAll('.order-checkbox'));
        const checkedIndexes = allCheckboxes.map((cb, idx) => cb.checked ? idx : -1).filter(i => i >= 0);

        // If none checked -> print all
        const indexesToPrint = checkedIndexes.length > 0 ? checkedIndexes : Array.from(itemLines.keys());

        // Build HTML rows for selected items
        let itemsHtml = '';
        indexesToPrint.forEach(i => {
            const item = itemLines[i] || '';
            const qty = qtyLines[i] || '';
            const price = priceLines[i] || '';
            const total = totalLines[i] || '';
            itemsHtml += `<tr>
                <td style="padding:6px;border-bottom:1px solid #eee">${item}</td>
                <td style="padding:6px;border-bottom:1px solid #eee;text-align:center">${qty}</td>
                <td style="padding:6px;border-bottom:1px solid #eee;text-align:right">${price}</td>
                <td style="padding:6px;border-bottom:1px solid #eee;text-align:right">${total}</td>
            </tr>`;
        });

        const docHtml = `
            <!doctype html>
            <html>
            <head>
              <meta charset="utf-8">
              <title>Order Print</title>
              <style>
                body{font-family:Arial,Helvetica,sans-serif;margin:0;padding:10px;color:#111}
                .card{width:320px}
                h2{font-size:16px;margin:0 0 8px}
                .meta{font-size:13px;color:#333;margin-bottom:6px}
                table{width:100%;border-collapse:collapse;margin-top:8px}
                th{font-size:13px;text-align:left;padding:6px;border-bottom:1px solid #ccc}
                td{font-size:13px}
                .right{text-align:right}
                .center{text-align:center}
              </style>
            </head>
            <body>
              <div class="card">
                <h2>Order</h2>
                <div class="meta"><strong>Mobile:</strong> ${mobile}</div>
                <div class="meta"><strong>Date:</strong> ${date} &nbsp; <strong>Time:</strong> ${time}</div>
                <table>
                  <thead>
                    <tr>
                      <th>Item</th>
                      <th class="center">Qty</th>
                      <th class="right">Price</th>
                      <th class="right">Total</th>
                    </tr>
                  </thead>
                  <tbody>
                    ${itemsHtml}
                  </tbody>
                </table>
              </div>
            </body>
            </html>
        `;

        // Hidden iframe printing (auto opens print dialog)
        const iframe = document.createElement('iframe');
        iframe.style.position = 'absolute';
        iframe.style.left = '-9999px';
        iframe.style.width = '0';
        iframe.style.height = '0';
        iframe.style.border = '0';
        document.body.appendChild(iframe);

        const idoc = iframe.contentDocument || iframe.contentWindow.document;
        idoc.open();
        idoc.write(docHtml);
        idoc.close();

        function doPrintAndCleanup() {
            try {
                const win = iframe.contentWindow || iframe;
                win.focus();
                if (typeof win.print === 'function') win.print();
            } catch (err) {
                console.warn('Print failed:', err);
            }
            setTimeout(() => {
                if (iframe && iframe.parentNode) iframe.parentNode.removeChild(iframe);
            }, 800);
        }

        iframe.onload = function () {
            setTimeout(doPrintAndCleanup, 200);
        };
        setTimeout(doPrintAndCleanup, 500);
    }

    // Handle form submissions
    function initOrderForms() {
        document.querySelectorAll('.order-action-form').forEach(form => {
            // Record which submit button was clicked (so we can include its value in FormData)
            form.querySelectorAll('button[type="submit"]').forEach(btn => {
                btn.addEventListener('click', function (ev) {
                    // store on the form; will be consumed by the submit handler
                    form.dataset.clickedAction = this.value;

                    // If Accept clicked, print the current row as a mini card (user gesture)
                    if (this.value === 'accept') {
                        const row = form.closest('tr');
                        printMiniCardForRow(row);
                    }
                });
            });
             // Add checkbox change listener to the row
             const row = form.closest('tr');
             if (row) {
                 row.querySelectorAll('.order-checkbox').forEach(checkbox => {
                     checkbox.addEventListener('change', function () {
                         updateOrderIdsInForm(form);
                     });
                 });
             }

             // Form submission
             form.addEventListener('submit', async function (e) {
                 e.preventDefault();

                 // Update order_ids based on checked checkboxes
                 updateOrderIdsInForm(this);

                 // Check if any orders are selected
                 const checkedBoxes = this.closest('tr').querySelectorAll('.order-checkbox:checked');
                 if (checkedBoxes.length === 0) {
                     toastr.warning('Please select at least one order');
                     return;
                 }

                const formData = new FormData(this);
                // include the clicked button value (if any) — browsers don't add the clicked submit to FormData when submit is handled by JS
                const clicked = this.dataset.clickedAction;
                if (clicked) {
                    formData.set('action', clicked);
                    delete this.dataset.clickedAction;
                }
                const action = formData.get('action');

                 const formAction = this.getAttribute('action');

                 // Log the form action URL for debugging
                 console.log('Form action URL:', formAction);
                 console.log('FormData contents:', {
                     action: action,
                     order_ids: formData.getAll('order_ids')
                 });

                 try {
                     // Ensure we have a valid action URL
                     if (!formAction || typeof formAction !== 'string') {
                         toastr.error('Invalid form action URL. See console for details.');
                         console.error('Invalid formAction:', formAction, this);
                         return;
                     }

                     // Prefer CSRF token from the form itself (csrfmiddlewaretoken input),
                     // fall back to cookie-based CSRFTOKEN
                     const csrfFromForm = formData.get('csrfmiddlewaretoken');
                     const csrfHeader = csrfFromForm || CSRFTOKEN || '';

                     const response = await fetch(formAction, {
                          method: 'POST',
                          body: formData,
                          credentials: 'same-origin',
                          headers: {
                              'X-Requested-With': 'XMLHttpRequest',
                              'X-CSRFToken': csrfHeader
                          }
                      });

                    // Check if response is OK (status 200-299)
                    if (!response.ok) {
                        const errorText = await response.text();
                        console.error('HTTP Error:', response.status, errorText);
                        toastr.error(`Server error: ${response.status} ${response.statusText}\nURL: ${formAction}\nCheck console for details`);
                        return;
                    }

                    let data;
                    try {
                        data = await response.json();
                    } catch (parseErr) {
                        console.error('JSON Parse Error:', parseErr);
                        const responseText = await response.text();
                        console.error('Response text:', responseText);
                        toastr.error('Invalid server response — check console for details');
                        return;
                    }

                    if (data.success) {
                         // Show toast notification
                         toastr.success(data.message);

                         // Update visible status text and hidden span for each checked order
                         checkedBoxes.forEach(checkbox => {
                             const orderId = checkbox.value;
                            
                            // Update visible status span in the checkbox row
                            const checkboxDiv = checkbox.closest('.flex.items-center.mb-1');
                            if (checkboxDiv) {
                                const statusSpan = checkboxDiv.querySelector('span.inline-block');
                                if (statusSpan) {
                                    statusSpan.textContent = data.new_status;
                                }
                            }

                            // Update hidden status cell (for JS color updates)
                             const statusCell = document.getElementById(`status-${orderId}`);
                             if (statusCell) {
                                 statusCell.textContent = data.new_status;
                                 updateStatusColor(statusCell, data.new_status);
                             }
                         });

                        // Uncheck all checkboxes after successful submission
                        checkedBoxes.forEach(checkbox => {
                            checkbox.checked = false;
                        });

                         // Update navbar badge if order count changed
                         if (data.pending_count !== undefined) {
                             updateOrderBadge(data.pending_count);
                             showPendingOrdersAlert(data.pending_count);
                         } else {
                             showPendingOrdersAlert();
                         }

                         // Refresh orders table
                         refreshTbody('order-food-tbody');
                     } else {
                        console.error('Backend error:', data);
                        toastr.error(data.message || 'Backend error — check console');
                     }
                 } catch (error) {
                    console.error('Fetch error:', error);
                    toastr.error(`Failed to process: ${error.message}`);
                 }
             });
         });
     }

    function updateOrderBadge(count) {
        const badge = document.getElementById('order-count-badge');
        if (badge) {
            badge.textContent = count;
            badge.style.display = count > 0 ? 'inline-block' : 'none';
        }
    }

    function updateStatusColor(cell, status) {
        cell.className = 'px-4 py-2 border';
        if (status === 'Accepted') cell.classList.add('bg-green-100');
        else if (status === 'Making') cell.classList.add('bg-yellow-100');
        else if (status === 'Ready to Collect') cell.classList.add('bg-blue-100');
        else if (status === 'Delivered') cell.classList.add('bg-purple-100');
        else if (status === 'Cancelled') cell.classList.add('bg-red-100');
    }

    function initCancelModal() {
        const modal = document.getElementById('cancel-modal');
        const modalConfirmBtn = document.getElementById('modal-confirm-btn');
        const modalCancelBtn = document.getElementById('modal-cancel-btn');
        const reasonTextarea = document.getElementById('cancel-reason-textarea');
        const cancelButtons = document.querySelectorAll('.cancel-btn');
        let activeForm = null;

        // detach previous listeners safely by cloning modal (simple reset)
        const modalClone = modal.cloneNode(true);
        modal.parentNode.replaceChild(modalClone, modal);

        // re-select elements from the fresh DOM
        const freshModal = document.getElementById('cancel-modal');
        const freshConfirm = document.getElementById('modal-confirm-btn');
        const freshCancel = document.getElementById('modal-cancel-btn');
        const freshTextarea = document.getElementById('cancel-reason-textarea');

        document.querySelectorAll('.cancel-btn').forEach(button => {
            button.removeAttribute('onclick');
            button.addEventListener('click', function (event) {
                event.preventDefault();
                activeForm = button.closest('form');
                freshModal.style.display = 'flex';
            });
        });

        freshCancel.addEventListener('click', function () {
            freshModal.style.display = 'none';
            freshTextarea.value = '';
        });

        // Use AJAX for confirm so CSRF header is included
        freshConfirm.addEventListener('click', async function () {
            if (!activeForm) return;
            const url = activeForm.action;
            const fd = new FormData(activeForm);
            fd.set('action', 'cancel');
            fd.set('reason', freshTextarea.value || '');

            try {
                // Prefer CSRF token from the form; fallback to cookie-based token.
                const csrfFromForm = fd.get('csrfmiddlewaretoken');
                const csrfHeader = csrfFromForm || CSRFTOKEN || '';
                const resp = await fetch(url, {
                    method: 'POST',
                    body: fd,
                    credentials: 'same-origin',
                    headers: {
                        'X-Requested-With': 'XMLHttpRequest',
                        'X-CSRFToken': csrfHeader
                    }
                });
                const data = await resp.json();
                if (data.success) {
                    toastr.success(data.message);
                    const orderId = activeForm.dataset.orderId;
                    const statusCell = document.getElementById(`status-${orderId}`);
                    if (statusCell) {
                        statusCell.textContent = data.new_status;
                        updateStatusColor(statusCell, data.new_status);
                    }
                    if (data.pending_count !== undefined) {
                        updateOrderBadge(data.pending_count);
                        showPendingOrdersAlert(data.pending_count);
                    } else {
                        showPendingOrdersAlert();
                    }
                    refreshTbody('order-food-tbody');
                    freshModal.style.display = 'none';
                    freshTextarea.value = '';
                } else {
                    toastr.error(data.message || 'Cancellation failed');
                }
            } catch (err) {
                console.error('Cancel request failed', err);
                toastr.error('Failed to cancel the order');
            }
        });

        freshModal.addEventListener('click', function (event) {
            if (event.target === freshModal) {
                freshModal.style.display = 'none';
                freshTextarea.value = '';
            }
        });
    }

    // Replace tbody by fetching current page and extracting tbody#order-food-tbody
    async function refreshTbody(tbodyId) {
        try {
            const res = await fetch(window.location.href, { headers: { 'X-Requested-With': 'XMLHttpRequest' } });
            if (!res.ok) return;
            const html = await res.text();
            const parser = new DOMParser();
            const doc = parser.parseFromString(html, 'text/html');
            const newTbody = doc.querySelector('#' + tbodyId);
            if (newTbody) {
                const current = document.querySelector('#' + tbodyId);
                if (current && current.innerHTML !== newTbody.innerHTML) {
                    current.innerHTML = newTbody.innerHTML;
                    // re-initialize behaviour for dynamic parts
                    initOrderForms();
                     initCancelModal();
                     // refresh pending banner based on new DOM
                     showPendingOrdersAlert();
                }
            }
        } catch (e) {
            console.error('refreshTbody error:', e);
        }
    }

    function startRealtimeOrders() {
        // If running on local development hosts, avoid opening a WebSocket (browser will log connection failures).
        const localHosts = ['127.0.0.1', 'localhost'];
        if (localHosts.includes(location.hostname)) {
            // Use polling fallback only (silent - no console output)
            setInterval(() => refreshTbody('order-food-tbody'), 5000);
            return;
        }

        const wsProtocol = (location.protocol === 'https:') ? 'wss:' : 'ws:';
        const wsUrl = wsProtocol + '//' + location.host + '/ws/admin/orders/';
        let socket;
        try {
            socket = new WebSocket(wsUrl);
        } catch (e) {
            socket = null;
        }
        if (socket) {
            socket.addEventListener('message', () => refreshTbody('order-food-tbody'));
            socket.addEventListener('close', () => setInterval(() => refreshTbody('order-food-tbody'), 5000));
            socket.addEventListener('error', () => setInterval(() => refreshTbody('order-food-tbody'), 5000));
            // occasional full sync
            setInterval(() => refreshTbody('order-food-tbody'), 15000);
        } else {
            setInterval(() => refreshTbody('order-food-tbody'), 5000);
        }
    }

    // Helper: try to play beep (no error thrown)
    function tryPlayBeep() {
        const beepAudio = document.getElementById('pending-beep-audio');
        if (!beepAudio) return;
        try {
            beepAudio.volume = 0.6;
            beepAudio.currentTime = 0;
            beepAudio.play().catch(err => {
                console.warn('Audio play failed (may require user gesture):', err);
            });
        } catch (err) {
            console.warn('Beep play error:', err);
        }
    }

    // New: timer handle for delayed beep and helper to stop/cleanup
    let pendingBeepTimer = null;
    function stopPendingBeep() {
        const beepAudio = document.getElementById('pending-beep-audio');
        if (pendingBeepTimer) {
            clearTimeout(pendingBeepTimer);
            pendingBeepTimer = null;
        }
        if (beepAudio) {
            try {
                beepAudio.pause();
                beepAudio.currentTime = 0;
                beepAudio.loop = false;
            } catch (e) {
                console.warn('Failed to stop beep:', e);
            }
        }
    }

    // Show pending orders count in a toastr alert AND update the persistent banner.
    function showPendingOrdersAlert(count) {
        let pendingCount = typeof count === 'number' ? count : null;
        if (pendingCount === null) {
            // Count each individual "Pending" status in the table
             const tbody = document.getElementById('order-food-tbody');
             if (tbody) {
                const statusSpans = tbody.querySelectorAll('td:nth-child(9) .text-sm.text-gray-700 span:not(.hidden)');
                 pendingCount = 0;
                statusSpans.forEach(span => {
                    const statusText = (span.textContent || '').trim().toLowerCase();
                     if (statusText.includes('pending')) {
                         pendingCount++;
                     }
                 });
             } else {
                 pendingCount = 0;
             }
         }

         const banner = document.getElementById('pending-alert-banner');
         const bannerText = document.getElementById('pending-alert-text');
         const okBtn = document.getElementById('pending-ok-btn');
         const beepAudio = document.getElementById('pending-beep-audio');

         // ensure OK button has a fresh listener (remove previous)
         if (okBtn && okBtn.parentNode) {
            const newOk = okBtn.cloneNode(true);
            okBtn.parentNode.replaceChild(newOk, okBtn);
         }

         const freshOkBtn = document.getElementById('pending-ok-btn');

         if (pendingCount > 0) {
            toastr.info(`${pendingCount} pending order${pendingCount > 1 ? 's' : ''}`, 'Pending Orders');

            if (bannerText) bannerText.textContent = `${pendingCount} pending order${pendingCount > 1 ? 's' : ''} — please review.`;
            banner.classList.remove('hidden');

            // start beep after 1 second, loop until user clicks OK
            if (beepAudio) {
                stopPendingBeep();
                pendingBeepTimer = setTimeout(() => {
                    beepAudio.loop = true;
                    tryPlayBeep();
                }, 1000);
            }

            // when OK clicked stop beep and hide banner
            if (freshOkBtn) {
                freshOkBtn.addEventListener('click', function () {
                    stopPendingBeep();
                    banner.classList.add('hidden');
                });
            }

        } else {
            // no pending orders -> hide banner and stop audio
            stopPendingBeep();
            banner.classList.add('hidden');
            if (bannerText) bannerText.textContent = '';
        }
    }

    document.addEventListener('DOMContentLoaded', function () {
         initOrderForms();
         initCancelModal();
         startRealtimeOrders();

         // NOTE: Removed auto-start of background music on page load to respect autoplay/user-gesture policies.
         // showPendingOrdersAlert will start audio (after 1s) only when pending orders are detected.
         showPendingOrdersAlert(); // display pending count on load
     });
</script>
{% endblock %}